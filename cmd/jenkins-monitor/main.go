package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"jenkins-monitor/internal/adhoc"
	"jenkins-monitor/internal/analyze"
	"jenkins-monitor/internal/config"
	"jenkins-monitor/internal/monitor"
	"jenkins-monitor/internal/utils"
)

func main() {
	// Determine default paths based on binary location
	exe, err := os.Executable()
	if err != nil {
		panic(fmt.Errorf("failed to get executable path: %v", err))
	}
	exeDir := filepath.Dir(exe)
	defaultCSVPath := filepath.Join(exeDir, "jenkins_job_monitor.csv")

	// Define a global config flag
	configPath := flag.String("config", "config.yaml", "Path to the YAML configuration file")
	logFilePath := flag.String("log-file", "/tmp/jenkinsjobmonitor.log", "Path to the log file")
	flag.Parse() // Parse global flags before subcommand parsing

	utils.SetupLogging(*logFilePath) // Initialize logging first

	cfg, err := config.LoadConfig(*configPath)
	if err != nil {
		utils.Fatal(fmt.Sprintf("Failed to load configuration: %v", err))
	}

	// After global flag parsing, flag.Args() contains the non-flag arguments.
	// flag.Args()[0] should be the subcommand.
	if len(flag.Args()) < 1 {
		printUsage()
		return
	}

	switch flag.Args()[0] {
	case "monitor":
		monitorCmd := flag.NewFlagSet("monitor", flag.ContinueOnError)
		outputFile := monitorCmd.String("output", defaultCSVPath, "Path to the output CSV file")
		monitorCmd.Usage = func() {
			fmt.Fprintf(os.Stderr, "Usage of %s monitor:\n", os.Args[0])
			fmt.Fprintf(os.Stderr, "  Monitors Jenkins processes and logs CPU/memory usage to a CSV file.\n")
			fmt.Fprintf(os.Stderr, "  Prometheus metrics are exposed based on the configuration file.\n")
			monitorCmd.PrintDefaults()
		}
		if err := monitorCmd.Parse(flag.Args()[1:]); err != nil {
			utils.Fatal(fmt.Sprintf("Error parsing monitor command flags: %v", err))
		}
		monitor.RunMonitor(*outputFile, cfg)
	case "analyze":
		analyzeCmd := flag.NewFlagSet("analyze", flag.ContinueOnError)
		inputFile := analyzeCmd.String("input", defaultCSVPath, "Path to the input CSV file")
		analyzeCmd.Usage = func() {
			fmt.Fprintf(os.Stderr, "Usage of %s analyze:\n", os.Args[0])
			fmt.Fprintf(os.Stderr, "  Analyzes a CSV file generated by the monitor command to report peak CPU and memory usage.\n")
			analyzeCmd.PrintDefaults()
		}
		if err := analyzeCmd.Parse(flag.Args()[1:]); err != nil {
			utils.Fatal(fmt.Sprintf("Error parsing analyze command flags: %v", err))
		}
		analyze.RunAnalyzer(*inputFile)
	case "adhoc":
		adhocCmd := flag.NewFlagSet("adhoc", flag.ContinueOnError)
		adhocCmd.Usage = func() {
			fmt.Fprintf(os.Stderr, "Usage of %s adhoc:\n", os.Args[0])
			fmt.Fprintf(os.Stderr, "  Performs an immediate scan of running Jenkins processes and displays their CPU and memory usage.\n")
			adhocCmd.PrintDefaults()
		}
		if err := adhocCmd.Parse(flag.Args()[1:]); err != nil {
			utils.Fatal(fmt.Sprintf("Error parsing adhoc command flags: %v", err))
		}
		adhoc.RunAdhoc()
	default:
		printUsage()
	}
}

func printUsage() {
	fmt.Fprintf(os.Stderr, "Usage: %s <command> [arguments]\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\nCommands:\n")
	fmt.Fprintf(os.Stderr, "  monitor   Continuously monitors Jenkins processes and logs data to a CSV file. Exposes Prometheus metrics based on config.\n")
	fmt.Fprintf(os.Stderr, "  analyze   Analyzes a CSV file to report peak CPU and memory usage.\n")
	fmt.Fprintf(os.Stderr, "  adhoc     Performs an immediate scan of Jenkins processes.\n")
	fmt.Fprintf(os.Stderr, "\nUse \"%s <command> -h\" for more information about a command.\n", os.Args[0])
}
